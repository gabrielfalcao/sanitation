use std::fmt;
use std::str::from_utf8;

//       _/_/_/    _/_/_/    _/                _/
//    _/        _/        _/_/_/_/  _/  _/_/      _/_/_/      _/_/_/
//     _/_/      _/_/      _/      _/_/      _/  _/    _/  _/    _/
//        _/        _/    _/      _/        _/  _/    _/  _/    _/
// _/_/_/    _/_/_/        _/_/  _/        _/  _/    _/    _/_/_/
//                                                          _/
//                                                       _/_/

/// SString (Sanitation String) is, in a nutshell, a string from a
/// UTF-8 byte-sequence with garbage collection for later
/// analysis. SString is intended for use in binary-protocol
/// implementations (e.g.: RFC-4251
/// <https://datatracker.ietf.org/doc/html/rfc4251#section-5>) or
/// other occasions where the definition of `string` as appears as
/// some kind or sort of binary string expecting valid UTF-8.

/// In other words SString is a data-structure acting as a
/// dual-data-channel where the garbage can be analysed for capturing
/// bugs in connections, revealing bugs in remote connections and
/// generally detecting problems e.g.: buffer-overflow attacks.
///
/// ```
/// // Based on https://www.exploit-db.com/exploits/51641
/// use sanitation::SString;
/// let general_device_manager = vec![
///     0xb8, 0x9c, 0x78, 0x14, 0x60, 0xd9, 0xc2, 0xd9,
///     0x74, 0x24, 0xf4, 0x5a, 0x33, 0xc9, 0xb1, 0x31,
///     0x83, 0xea, 0xfc, 0x31, 0x42, 0x0f, 0x03, 0x42,
///     0x93, 0x9a, 0xe1, 0x9c, 0x43, 0xd8, 0x0a, 0x5d,
///     0x93, 0xbd, 0x83, 0xb8, 0xa2, 0xfd, 0xf0, 0xc9,
///     0x94, 0xcd, 0x73, 0x9f, 0x18, 0xa5, 0xd6, 0x34,
///     0xab, 0xcb, 0xfe, 0x3b, 0x1c, 0x61, 0xd9, 0x72,
///     0x9d, 0xda, 0x19, 0x14, 0x1d, 0x21, 0x4e, 0xf6,
///     0x1c, 0xea, 0x83, 0xf7, 0x59, 0x17, 0x69, 0xa5,
///     0x32, 0x53, 0xdc, 0x5a, 0x37, 0x29, 0xdd, 0xd1,
///     0x0b, 0xbf, 0x65, 0x05, 0xdb, 0xbe, 0x44, 0x98,
///     0x50, 0x99, 0x46, 0x1a, 0xb5, 0x91, 0xce, 0x04,
///     0xda, 0x9c, 0x99, 0xbf, 0x28, 0x6a, 0x18, 0x16,
///     0x61, 0x93, 0xb7, 0x57, 0x4e, 0x66, 0xc9, 0x90,
///     0x68, 0x99, 0xbc, 0xe8, 0x8b, 0x24, 0xc7, 0x2e,
///     0xf6, 0xf2, 0x42, 0xb5, 0x50, 0x70, 0xf4, 0x11,
///     0x61, 0x55, 0x63, 0xd1, 0x6d, 0x12, 0xe7, 0xbd,
///     0x71, 0xa5, 0x24, 0xb6, 0x8d, 0x2e, 0xcb, 0x19,
///     0x04, 0x74, 0xe8, 0xbd, 0x4d, 0x2e, 0x91, 0xe4,
///     0x2b, 0x81, 0xae, 0xf7, 0x94, 0x7e, 0x0b, 0x73,
///     0x38, 0x6a, 0x26, 0xde, 0x56, 0x6d, 0xb4, 0x64,
///     0x14, 0x6d, 0xc6, 0x66, 0x08, 0x06, 0xf7, 0xed,
///     0xc7, 0x51, 0x08, 0x24, 0xac, 0xae, 0x42, 0x65,
///     0x84, 0x26, 0x0b, 0xff, 0x95, 0x2a, 0xac, 0xd5,
///     0xd9, 0x52, 0x2f, 0xdc, 0xa1, 0xa0, 0x2f, 0x95,
///     0xa4, 0xed, 0xf7, 0x45, 0xd4, 0x7e, 0x92, 0x69,
///     0x4b, 0x7e, 0xb7, 0x09, 0x0a, 0xec, 0x5b, 0xe0,
///     0xa9, 0x94, 0xfe, 0xfc,
/// ];
///
/// let gdm = SString::new(&general_device_manager);
///
/// assert_eq!(gdm.garbage(), vec![184, 156, 217, 194, 217, 244, 131, 234, 252, 147, 154, 225, 156, 216, 147, 189, 131, 184, 162, 253, 240, 205, 159, 165, 214, 171, 203, 254, 217, 157, 218, 246, 234, 131, 247, 165, 220, 221, 209, 191, 152, 153, 181, 145, 206, 153, 191, 147, 183, 153, 188, 232, 139, 199, 246, 242, 181, 244, 209, 231, 189, 165, 182, 141, 203, 232, 189, 145, 228, 129, 174, 247, 148, 222, 180, 198, 247, 237, 199, 172, 174, 132, 255, 149, 172, 213, 217, 160, 149, 164, 237, 247, 212, 146, 183, 236, 254, 252]);
/// assert_eq!(&gdm.soft_word(), "x\u{14}`t$Z3ɱ11B\u{f}\u{3}BC\n]ɔs\u{18}4;\u{1c}ar\u{19}\u{14}\u{1d}!N\u{1c}Y\u{17}i2SZ7)\u{b}e\u{5}۾DPF\u{1a}\u{4}ڜ(j\u{18}\u{16}aWNfɐh$.BPp\u{11}aUcm\u{12}q$.\u{19}\u{4}tM.+~\u{b}s8j&Vmd\u{14}mf\u{8}\u{6}Q\u{8}$Be&\u{b}*R/ܡ/E~iK~\t\n[\u{a54}");
/// ```

//
#[derive(Clone)]
pub struct SString(Vec<u8>, Option<Vec<u8>>);

impl fmt::Display for SString {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.soft_word())
    }
}
impl fmt::Debug for SString {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        let gbg = self.garbage();
        write!(fmt, "sanitation-string: {}", self.soft_word())?;
        write!(fmt, "\r\ngarbage: 0x{}", gbg.iter().map(|x| format!("{:02x}", x)).collect::<Vec<String>>().join(""))
    }
}

impl SString {
    pub fn new(input: &[u8]) -> SString {
        let mut input = input.to_vec();
        let mut string: Vec<u8> = Vec::new();
        let mut garbage: Vec<u8> = Vec::new();
        loop {
            match from_utf8(&input) {
                Ok(valid) => {
                    string.extend(valid.as_bytes());
                    break;
                }
                Err(error) => {
                    let (valid, after_valid) = input.split_at(error.valid_up_to());
                    string.extend(valid);

                    if let Some(il) = error.error_len() {
                        let is = error.valid_up_to();
                        let ie = is + il;
                        let byte = &input[is..ie];
                        garbage.extend(byte);
                        input = after_valid[il..].to_vec();
                    } else {
                        break;
                    }
                }
            }
        }
        SString(
            string,
            if garbage.len() > 0 {
                Some(garbage)
            } else {
                None
            },
        )
    }
    pub fn soft_word(&self) -> String {
        String::from_utf8(self.0.clone()).expect("garbage to evidently possess some data")
    }
    pub fn soft_string(&self) -> Vec<u8> {
        self.0.clone()
    }
    pub fn garbage(&self) -> Vec<u8> {
        match &self.1 {
            None => Vec::new(),
            Some(v) => v.clone(),
        }
    }
}


#[cfg(test)]
mod sstring_tests {
    use super::SString;

    #[test]
    pub fn test_sstring_from_invalid_utf8() {
        let invalid_utf8_bytes: Vec<u8> = vec![
            0xff, 0x72, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x31, 0x47, 0x31,
        ];

        assert_eq!(
            String::from_utf8_lossy(&invalid_utf8_bytes),
            format!("�r������1G1")
        );
        let ssh_string = SString::new(&invalid_utf8_bytes);
        let ss = ssh_string.soft_string();
        assert_eq!(ss, vec![0x72, 0x31, 0x47, 0x31]);
        let sw = ssh_string.soft_word();
        assert_eq!(sw, format!("r1G1"));
        let gbg = ssh_string.garbage();
        assert_eq!(gbg, vec![0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe]);
    }

    #[test]
    pub fn test_capture_hospital_run_exploit() {
        // Example from https://www.exploit-db.com/exploits/51310
        let hospital_run = vec![0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x72, 0x65, 0x6E, 0x64, 0x65, 0x72, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x3D, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x2E, 0x61, 0x74, 0x6F, 0x6D, 0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x28, 0x27, 0x72, 0x65, 0x6E, 0x64, 0x65, 0x72, 0x5F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x27, 0x29, 0x2E, 0x66, 0x6F, 0x72, 0x41, 0x6C, 0x6C, 0x57, 0x65, 0x62, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x28, 0x29];
        let hr = SString::new(&hospital_run);

        assert_eq!(hr.garbage(), vec![]);
        assert_eq!(&hr.soft_word(), "const renderProcessPreferences = process.atomBinding('render_process_preferences').forAllWebContents()");
    }

    #[test]
    pub fn test_capture_maxiguvenlik_general_device_manager() {
        // Example from https://www.exploit-db.com/exploits/51641
        let general_device_manager = vec![
            0xb8, 0x9c, 0x78, 0x14, 0x60, 0xd9, 0xc2, 0xd9,
            0x74, 0x24, 0xf4, 0x5a, 0x33, 0xc9, 0xb1, 0x31,
            0x83, 0xea, 0xfc, 0x31, 0x42, 0x0f, 0x03, 0x42,
            0x93, 0x9a, 0xe1, 0x9c, 0x43, 0xd8, 0x0a, 0x5d,
            0x93, 0xbd, 0x83, 0xb8, 0xa2, 0xfd, 0xf0, 0xc9,
            0x94, 0xcd, 0x73, 0x9f, 0x18, 0xa5, 0xd6, 0x34,
            0xab, 0xcb, 0xfe, 0x3b, 0x1c, 0x61, 0xd9, 0x72,
            0x9d, 0xda, 0x19, 0x14, 0x1d, 0x21, 0x4e, 0xf6,
            0x1c, 0xea, 0x83, 0xf7, 0x59, 0x17, 0x69, 0xa5,
            0x32, 0x53, 0xdc, 0x5a, 0x37, 0x29, 0xdd, 0xd1,
            0x0b, 0xbf, 0x65, 0x05, 0xdb, 0xbe, 0x44, 0x98,
            0x50, 0x99, 0x46, 0x1a, 0xb5, 0x91, 0xce, 0x04,
            0xda, 0x9c, 0x99, 0xbf, 0x28, 0x6a, 0x18, 0x16,
            0x61, 0x93, 0xb7, 0x57, 0x4e, 0x66, 0xc9, 0x90,
            0x68, 0x99, 0xbc, 0xe8, 0x8b, 0x24, 0xc7, 0x2e,
            0xf6, 0xf2, 0x42, 0xb5, 0x50, 0x70, 0xf4, 0x11,
            0x61, 0x55, 0x63, 0xd1, 0x6d, 0x12, 0xe7, 0xbd,
            0x71, 0xa5, 0x24, 0xb6, 0x8d, 0x2e, 0xcb, 0x19,
            0x04, 0x74, 0xe8, 0xbd, 0x4d, 0x2e, 0x91, 0xe4,
            0x2b, 0x81, 0xae, 0xf7, 0x94, 0x7e, 0x0b, 0x73,
            0x38, 0x6a, 0x26, 0xde, 0x56, 0x6d, 0xb4, 0x64,
            0x14, 0x6d, 0xc6, 0x66, 0x08, 0x06, 0xf7, 0xed,
            0xc7, 0x51, 0x08, 0x24, 0xac, 0xae, 0x42, 0x65,
            0x84, 0x26, 0x0b, 0xff, 0x95, 0x2a, 0xac, 0xd5,
            0xd9, 0x52, 0x2f, 0xdc, 0xa1, 0xa0, 0x2f, 0x95,
            0xa4, 0xed, 0xf7, 0x45, 0xd4, 0x7e, 0x92, 0x69,
            0x4b, 0x7e, 0xb7, 0x09, 0x0a, 0xec, 0x5b, 0xe0,
            0xa9, 0x94, 0xfe, 0xfc,
        ];

        let gdm = SString::new(&general_device_manager);

        assert_eq!(gdm.garbage(), vec![184, 156, 217, 194, 217, 244, 131, 234, 252, 147, 154, 225, 156, 216, 147, 189, 131, 184, 162, 253, 240, 205, 159, 165, 214, 171, 203, 254, 217, 157, 218, 246, 234, 131, 247, 165, 220, 221, 209, 191, 152, 153, 181, 145, 206, 153, 191, 147, 183, 153, 188, 232, 139, 199, 246, 242, 181, 244, 209, 231, 189, 165, 182, 141, 203, 232, 189, 145, 228, 129, 174, 247, 148, 222, 180, 198, 247, 237, 199, 172, 174, 132, 255, 149, 172, 213, 217, 160, 149, 164, 237, 247, 212, 146, 183, 236, 254, 252]);
        assert_eq!(&gdm.soft_word(), "x\u{14}`t$Z3ɱ11B\u{f}\u{3}BC\n]ɔs\u{18}4;\u{1c}ar\u{19}\u{14}\u{1d}!N\u{1c}Y\u{17}i2SZ7)\u{b}e\u{5}۾DPF\u{1a}\u{4}ڜ(j\u{18}\u{16}aWNfɐh$.BPp\u{11}aUcm\u{12}q$.\u{19}\u{4}tM.+~\u{b}s8j&Vmd\u{14}mf\u{8}\u{6}Q\u{8}$Be&\u{b}*R/ܡ/E~iK~\t\n[\u{a54}");
    }
}
